# 腾讯 C++ 语言编程指南

编辑：theodorewu(吴银光)，directorgu(顾宇)，phongchen(陈峰)

[TOC]

## 简介

### 目标

本文档是基于 PCG 代码委员会 C++ 分会在 Code Review 中总结的编程实践集合，展示了在 C++ 编程中常见的问题和推荐方案，用于帮助 C++ 程序员写出更简单、更高效、更易于维护的 C++ 代码。

### 非目标

虽然本文档的部分内容不可避免的会涉及 C++ 语法和 C++ 编码规范，但这不是我们的目标，我们更聚焦在实际业务开发过程中的经验，建议读者在阅读本文档之前先熟悉 C++ 语法和 [C++ 编码规范](https://git.woa.com/standards/cpp)。

### 行文风格

本文不是基于类型、函数、类等层级来组织文档，而是基于编程过程中的常见问题来组织。

## 1. 代码提交日志内容完整可读

不同团队对代码提交日志有不同的格式要求。譬如，有些团队要求提交日志必须包括三部分。建议采用[约定式提交](https://www.conventionalcommits.org/zh-hans/v1.0.0/)编写代码提交信息。

- 头部一句话总结，同时要带有 `feat|fix|docs|style|refactor|test|chore` 标签
- 中间详细介绍
- 尾部 tapd story id，关联需求详情

有的团队则要求比较简单，只要有标签、tapd story id、做了什么即可。
总的来说，无论是什么样的格式要求，都必须讲清楚做了什么。
反例：

```text
feat: 重构 rpc 管理器
```

上述例子的提交日志标签用错，重构应该是 refactor，不是 feat。
反例：

```text
fix: 修复 bug
```

上述例子的提交日志，没有说清楚具体修复了什么 bug。

## 2. 一条提交日志对应一个功能

代码不是一次成型的，有些开发者会多次提交，最终在主干上会看到多条重复的提交日志，这是不合理的，应该合并为一条提交日志。我们有几种方式可以实现提交日志合并

- 在分支开发阶段，使用 git rebase 命令合并多条日志
- 在分支开发阶段，使用 git commit --amend，将当前的修改合并到上次的提交日志中
- 在分支合并阶段，采用 git squash merge，并编辑提交日志；同时我们建议使用工具生成的代码单独创建 MR 并且标题加上 `[AutoCode]` 前缀，以减少评审人的负担。

反例：

```text
11点30分 提交日志1：
feat: 新增视频排序功能

11点20分 提交日志2：
feat: 新增视频排序功能

11点05分 提交日志3：
feat: 新增视频排序功能
```

上述例子的多行提交日志对应同一个功能“新增视频排序功能”，应该合并为一次提交。

## 3. 代码注释风格一致

项目内的注释应该采用统一的注释风格，一致性包括几个方面：

- 哪些地方需要加注释
- 注释的格式

譬如，有些项目会要求：

- 采用 doxygen 注释风格，便于生成文档
- 文件头采用一致的版权、作者、用途说明
- 头文件的函数、类定义、成员变量、成员函数等都必须有注释
- 中英文混写时，英文前后留/不留空格，需采用一致标准

基于这些要求，正例：

```c++
// Copyright 2023 Tencent Inc.  All rights reserved.
/**
 * @file data_platform/qbsearch_content_bridge/process/preprocess/douban_data_imputer/douban_data_imputer.h
 * @brief 豆瓣信息补全插件
 */
#pragma once

#include "data_platform/qbsearch_content_bridge/process/preprocess/preprocessor.h"

#include "trpc/client/http/http_service_proxy.h"

namespace data_platform {

class DoubanDataImputer : public Preprocessor {
 private:
  bool DoInit() override;

  bool DoProcess(const MessagePtr& message) override;

  /**
   * @brief 获取豆瓣id
   * @param json_data 消息中的json数据
   * @param id_json_key 豆瓣id在json字符串中的key
   * @param douban_id 豆瓣id
   * @return bool 获取状态
   */
  bool GetDoubanId(const sonic_json::Document& json_data, const std::string& id_json_key, std::string* douban_id);

 private:
  std::shared_ptr<trpc::http::HttpServiceProxy> douban_http_proxy_;  ///< 豆瓣http服务代理
};
}  // namespace data_platform

```

## 4. 注释要完整准确简洁

注释也是一种文档，需要注意基本的语法，确保能准确表达，需要遵守三要素：完整、准确、简洁。

反例：

```c++
/**
 * @brief 添加截断迁所有结果的 debug 信息
*/
```

上述例子注释中有错别字“迁”应是“前”。

反例：

```c++
  if (recorder_->HasEvent(event_id) || !EVENT_LOCKER->LockEvent(event_id)) {
    // 周期任务遇到事件冲突时，以已执行任务优先，直接跳过当前事件
    return true;
  }
```

上述例子注释表达的信息不完整，而且指代不清，容易有理解困惑：什么是“事件冲突”、具体是什么事件之间发生冲突。结合实际功能，更合理的表达是：如果执行过人工干预事件或者 kafka 增量消息事件，则定期更新任务放弃本次更新。  
反例：

```c++
LAST_FILE_SEQ = 1  # 数据文件根据时间戳倒序排序后, 待去重文件的上一份文件序号为1, 因为待去重数据文件(序号0)一定会在相同目录下
```

上述例子注释内容啰嗦，且容易误导，实际上代码里是根据文件名排序，而文件名是时间戳。建议注释修改为：数据文件按照文件名后缀序号逆序排列后，需要参与新旧去重计算的旧文件序号。

## 5. 常量需要注释

常量数字需要说明为什么是这个数字，以便于读者理解和系统的持续可维护。譬如，通过实验得出的常量，则需要记录实验过程，以便后续环境变化时，维护者能够重新构造该常量；通过经验推导得到常量，则需要介绍经验推导逻辑；如果是通过文档、手册得到的，则需要记录来源。  
反例：

```c++
static constexpr int kQUHotSignalLevel = 2;
```

上述例子缺少注释，为什么是 2 而不是其他数字，需要做说明。

## 6. 特殊逻辑需要注释

代码应该能自解释，如果因为业务策略不得以写出无法自解释的代码，那么应该给出对应的注释说明。

反例：

```c++
if (ctx->log.cache_status == ResourceCachestatus::kCacheUpdate) {
    Report(ResourceCachestatus::kCacheOff);
}
```

上述例子缺少注释，`cache_status` 为 `kCacheUpdate` 的时候要上报 `kCacheOff`，这个特殊策略需要做注释说明。

## 7. 关键信息需要注释

在接口和成员变量处，给出关键的注释信息，有利于加快阅读效率。

反例：

```c++
/**
* @brief 匹配器基类
*/
class MatcherBase {
 public:
  virtual void BuildBm25Factor(uint32_t q_tf, float q_term_weight, float boost);
  ...
 private:
  float bm25_q_part_ = 0;
  std::unordered_map<int, std::string> segment_sources_;
}
```

上述例子的接口和成员变量注释不完整。`BuildBm25Factor` 应该增加函数功能和参数的注释，成员变量 `bm25_q_part_` 和 `segment_sources_` 应该说明其内容和用途。同时 `key-value` 类型的变量，建议采用 `${value}_by_${key}` 的命名风格，做到代码自解释。

## 8. 不要有多余的注释

注释不是越多越好，必须让读者得到价值的，有几种情况不需要注释：

- 无法删掉的废弃代码
- 对代码简单的重复

反例：

```c++
// xxx.proto

/// @deprecate GUID | QUA | CLIENT_IP | QQ |...
map<string, string> user_info = 3;
```

上述例子的注释不是必要的，既然是废弃的协议字段，描述废弃即可，不需要再描述它之前是干什么的。

反例：

```c++
TRPC_ASSERT(task_flow);  // 强制检查
```

上述例子的注释不是必要的，函数体内的注释要么是说明 why，要么是做阶段性总结，不应该写 what，what 是对代码内容的重复

## 9. 命名风格一致

项目内的各类命名都应该保持一致，包括文件、变量、函数、类等。老项目建议和原命名风格一致，不要强求采用腾讯编码规范，以免出现长期的代码规范混乱，除非能在较短时间内将代码规范统一起来或者已经代码规范混乱，新项目则要求统一遵循腾讯编码规范。

反例：

```c++
int count = 0;
auto promise_ptr = std::make_shared<trpc::Promise<trpc::Status>>();
```

上述例子的变量名 promise_ptr 不需要加上类型 ptr。

```c++
virtual bool Work(const Context& ctx) = 0;
virtual bool GetTestInfo(std::set<std::string>& test_info_) = 0;
```

上述例子的形参名 `test_info_` 应该去掉尾部的下划线。

## 10. 命名简洁准确完整

命名应该简洁、准确、完整，既不要有多余的信息，也不要词不达意，更不能不准确。

反例：

```c++
void SortPolicyHandler::Process() {
    ctx_->time_performance.SetBegin();
    ...
}
```

上述例子的变量名 `time_performance` 啰嗦且不准确。`time_performance` 翻译过来是：时间性能，这里更准确的用意应该是：时间消耗，因此建议修改为 `time_cost`，命名更短，且表达更准确。

反例：

```c++
// 数据源配置刷新时间间隔
static constexpr int32_t kConfigReloadInterval = 60;
```

上述例子的常量名 `kConfigReloadInterval` 可以加上 `Second` 变成 `kConfigReloadIntervalSecond`，通过命名就可以知道时间的单位。

反例：

```c++
int i = CountFunction();
int j = SumFunction();
...
```

上述例子的变量名 `i`、`j` 这类极短字符的命名，一般只用在 `for` 循环中，用来定义递增变量，其他地方不应该使用，不利于理解变量用途。

## 11. 避免容易混淆的命名

尽量提高命名的辨识度，减少读者误读的机会。

反例：

```c++
std::string TransDebugInfoToString(DebugInfo&& debug info);
std::string TransDebugInfosToString(DebugInfo&& debug info);
```

上述例子的函数名`TransDebugInfoToString` 和 `TransDebugInfosToString`，两个长字符串只有中间一个 `s` 字符不同，区分度很低，容易误读，建议修改为：`TransDebugInfoArrayToString`、`TransDebugInfoToString`。

## 12. 成员变量默认初始化

反例：

```c++
class FakeClass {
 public:
  FakeClass() : use_hot_cache_(true) {...}

 private:
  bool use_hot_cache_;
};
```

成员变量可以在定义处初始化，不用写初始化列表。

修正：

```c++
class FakeClass {
 public:
  FakeClass() {...}

 private:
  bool use_hot_cache_ = true;
};
```

修正后的代码更简洁。

## 13. 使用 for range 结构化绑定

反例：

```c++
for (const auto& ins: instances) {
  ins.first...
  ins.second...
}
```

我们建议使用 `for range` 代替 `for` 循环，在遇到 `unordered_map`/`map` 的时候使用结构化绑定。

修正：

```c++
for (const auto& [sid, plugin]: instances) {
  sid...
  plugin...
}
```

修改后的代码为 first、second 取了更清晰的命名，代码更易读懂。

## 14. 使用 unordered_map 代替 map

`unordered_map` 是 `C++11` 新引入的 `key-value` 容器，在多数评测下，其平均查找性能都高于 `map`，建议尽量采用 `unordered_map`，除非有以下情况：

 - 有对元素按顺序遍历的诉求
 - 更关注内存占用，而非读写性能
 - 业务场景下的评测发现 `map` 性能更好
 
 总的来说，我们建议用 unordered_map，但如果你的业务场景有特殊诉求，应该遵循相关场景下的规范或建议。譬如 `chromium` 就建议大多数场景用 `map` 即可：[map-and-set-selection](https://chromium.googlesource.com/chromium/src/base/+/refs/heads/main/containers/README.md#map-and-set-selection)。

## 15. 使用 emplace、try_emplace、emplace_back

`emplace` 系列接口可以实现原地对象构造，消除掉拷贝构造、移动构造等操作。

反例：

```c++
std::unordered_map<std::string, Demo> demo_group;
demo_group.insert(std::make_pair(key, Demo(value, i)));  // 案例一
demo_group.emplace(std::make_pair(key, Demo(value, i)));  // 案例二
```

上述例子中的两个插入元素举例，都是不高效的写法，其背后执行相同的计算流程： 首先构造 `Demo` 临时对象，然后用 `std::make_pair` 生成 `pair` 临时对象，最后 `pair` 临时对象移进 `demo_group`，这里在多个技术点上有性能浪费。

首先，有多个临时对象构造、移动构造带来的浪费。`Demo` 临时对象构造完之后，会执行两次 `move` 构造，第一次是生成 `pair` 对象时，第二次是进入 `demo_group` 时。`pair` 临时对象构造后也会执行一次移动构造。

然后，键值对插入失败时，也有临时对象构造的消耗。上述代码会先生成 `pair` 对象，然后在 `pair` 对象插入 `demo_group` 时才去判断是否可插入。

修正：

```c++
std::unordered_map<std::string, Demo> demo_group;
demo_group.try_emplace(key, value, i);
```

如果插入不成功，则所有临时对象都不会构造；如果插入成功，则只会原地构造一次，不会触发移动构造。上述例子中，如果 Demo 对象不需要在插入时实时构造，则可以改为 `demo_group.emplace(key, demo)` 或者 `demo_group.emplace(key, std::move(demo))`。

反例：

```c++
std::vector<Demo> demo_group;
demo_group.push_back(Demo(value, 1));  // 案例一
demo_group.emplace_back(Demo(value, 1));  // 案例二
```

上述例子中的两个案例，都是不高效的写法，其背后执行相同的计算流程：首先构造 Demo 临时对象，然后将临时对象移进 demo_group。

修正：

```c++
std::vector<Demo> demo_group;
demo_group.emplace_back(value, 1);
```

## 16. 使用 lambda 代替 std::bind

当 `lambda` 和 `std::bind` 都可以实现功能时，推荐使用 `lambda` 来做，可读性更强，这也是《Effective Modern C++》的建议。

反例：

```c++
trpc::TConfConfig tconf;
tconf.SetAsyCallBack(std::bind(&SortPolicyServer::ReInit, this, std::placeholders::_1));
```

修正：

```c++
trpc::TConfConfig tconf;
tconf.SetAsyCallBack([this](const std::map<std::string, TConf::ConfigValue>& update_config) {
  SortPolicyServer::ReInit(update_config);
});
```

## 17. 简单等待异步任务完成的场景可以考虑用 promise-future 代替条件变量

后台程序经常需要在工作线程里定期从外部存储加载数据，这里“定期”最差的做法是用 `sleep`，这会阻塞到进程退出。C++ 11 之前最佳的做法是使用带有条件变量的 `wait`，当进程退出时，可以激活条件变量，让 `wait` 及时得到通知而退出，这就要求有条件变量和锁，略复杂。现代 C++ 的做法使用 `promise-future`，更简单易懂。

反例：

```c++
void WorkThreadFunction() {
  while (true) {
    LoadData();
    sleep(30);
  }
}
```

上述例子中，为实现 30 秒定期加载数据，在加载数据工作线程中采用了睡眠 30 秒的实现，这是最差的做法，会阻塞进程退出。

使用条件变量：

```c++
std::mutex mutex;
std::condition_variable cv;
......
void WorkThreadFunction() {
  while (true) {
    LoadData();
    std::unique_lock locker(mutex);
    if (cv.wait_for(locker, std::chrono::seconds(30)) != std::cv_status::timeout) {
      break;
    }
  }
}

void ProcessExit() {
  std::unique_lock locker(mutex);
  cv.notify_all();
}
```

上述例子是 30 秒定期加载数据的条件变量实现方案，在工作线程的循环中使用条件变量的 `wait_for` 接口，同时在进程退出时触发条件变量信号，最终可以实现条件触发和定期触发。这是很传统的实现，有较多的代码，在现代 C++ 标准下，我们可以更优雅地实现。

使用 `promise-future`：

```c++

std::promise<void> promise;
std::future<void> future = promise.get_future();
......

void WorkThreadFunction() {
  while (true) {
    LoadData();
    if (future.wait_for(std::chrono::seconds(30)) == std::future_status::ready) {
      break;
    }
  }
});

void ProcessExit() {
  promise.set_value();
}
```

`promise-future` 在单次通知的场景上，相比使用条件变量更简单，这里有两份 demo 代码可以参考：

- [promsie_future_for_notify](https://git.woa.com/theodorewu/temp/blob/master/promsie_future_for_notify/a.cc)
- [promsie_future_for_wait](https://git.woa.com/theodorewu/temp/blob/master/promsie_future_for_wait/promsie_future_for_wait.cc)

另外，如果使用了 `trpc-cpp` 框架，定期加载数据可以直接用框架提供的定时任务，譬如：

```c++
trpc::PeripheryTaskScheduler::GetInstance()->SubmitPeriodicalTask([this]() { LoadData(); }, load_interval_ms_);
```

但是需要注意的是，`promise-future` 不能在所有场景下代替条件变量：

- `promise` 不允许多次调用 `set_value()`，所以上面示例中的 `ProcessExit` 方法只能调用一次，多次调用时会抛出异常，条件变量则可以多次通知和等待。
- 条件变量在 `wait` 系列方法成功返回后会重置信号，`future` 则会一直保持 “have value” 的状态，所以其行为是不一致的，`promise-future` 只能用于处理类似 “退出循环” 这个单次通知的场景，而条件变量写法则通用得多且具备更好的扩展性。比如多次通知工作进程，实现一个线程安全的阻塞队列等。
- 低版本的 GCC （4.8 及以下），`promise-future` 的标准库实现有 bug：
  - https://github.com/open-telemetry/opentelemetry-cpp/issues/2982
  - https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54297
  - https://stackoverflow.com/questions/28604461/using-c11-futures-nested-calls-of-stdasync-crash-compiler-standard-library

## 18. 合理使用右值引用和 std::move

右值引用常常和 `std::move` 搭配存在，在定义函数时，需要注意是否适合用右值引用，在调用函数时需要注意是否可以用 `std::move`。

反例：

```c++
std::string TransDebugInfoToString(DebugInfo&& debug_info) {
  std::string ret = debug_info.ToString();
  ...
  return ret;
}
```

上述例子中 `debug_info` 的成员变量没有被转移所有权，因此不需要设计为右值引用，定义为 `const&` 即可。

反例：

```c++
void DoSomething(const std::string& info) {
  DoSometingInner(std::move(info));
}
```

上述例子错误的对 `const&` 变量使用 `std::move`，`const&` 对象无法被 `move`，实际上执行的还是拷贝，这里的写法容易误导读者。

反例：

```c++
Demo DoSomething() {
  Demo demo;
  ...
  return std::move(demo);
}
```

上述例子错误的对返回值使用 `std::move`，编译器会做“返回值优化”（NRVO），在函数调用处原地构造返回对象，而此处的 `std::move` 会破坏 NRVO 优化，反而触发移动拷贝构造函数，降低了性能。

## 19. 合理使用 std::string_view

`string_view` 本质是字符串地址和字符串长度组成的结构体，在字符串分割、基于常量 `char*` 的初始化等场景下非常有价值，应该尽量使用，但也要避免过度使用。

正例：

```c++
constexpr std::string_view kSomething = "a";
constexpr char kSomething2[] = "b";
constexpr const char* kSomething3 = "c";
void DoSomething(std::string_view info);
// void DoSomething(const std::string& info); // 反面案例
...
DoSomething(kSomething);
DoSomething(kSomething2);
DoSomething(kSomething3);
```

上述例子中，三个实参都是常量字符串，此时参数类型使用 `string_view` 相比使用 `const std::string&` 消除了临时 `string` 对象的构造，更高效。

反例：

```c++
void AddBitsetQuery(std::string_view field, std::string_view term) {
  std::string key = std::string(field) + std::string(term);
  ...
}
...
std::string field = ...;
std::string term = ...;
AddBitsetQuery(field, term);
```

上述例子中调用者的 `field` 和 `term` 是经过一系列处理生成的，`AddBitsetQuery` 的形参定义为 `std::string_view` 相比 `const std::string&` 并没有优势，在函数调用时会触发 `std::string_view` 对象的构造，并传递该对象作为实参。而 `const std::string&` 作为形参，在执行时本质上是一个指针的值传递，`AddBitsetQuery` 函数在获取其字符串内容时相比 `std::string_view` 直接传递地址，会多一次寻址跳转，但相比构造 `std::string_view` 对象，`const std::string&` 还是更划算的。总的来说，如果函数调用传参会导致临时对象构造，则需要慎重，很可能是不值得的。

## 20. 合理使用 auto

使用 `auto` 应该遵循如下两个基本原则：

- 仅在能够让代码更清晰或更安全（避免意外的拷贝或类型转换）的情况下使用类型推导，并且不要仅仅为了避免编写显式类型的不便而使用 `auto` 。  
- 当判断代码是否更清晰时，记住读代码的人可能不在你的团队中或不熟悉这个项目，你觉得清晰的代码对其他人来说可能并不清晰。  

`auto` 可以让代码看起来更简洁，但有时候也会给代码的阅读理解带来障碍。

正例：

```c++
for (auto it = xx.begin(); it != xx.end(); ++it) {
  ...
}
```

上述例子里的迭代器使用了 `auto` 之后，代码显得更简洁。

反例：

```c++
auto something = Function();
auto somebody = something.Body();
auto ...
```

上述例子中，从上下文中无法得知 `somebody` 是什么类型时，但又需要访问其接口函数，这里的 `auto` 会给阅读带来障碍，应该指明具体类型。

## 21. 复用已有迭代器

在处理容器时，尽量复用已有的迭代器。

反例：

```c++
value->emplace(key, info);
std::string& info = value->at(key);
...
```

上述例子中先插入 kv 对，然后再用 k 去查找，是不高效的写法。

修正：

```c++
auto [it, suc] = value->emplace(key, info);
std::string& info = it->second;
...
```

反例：

```c++
if (map.find(key) != map.end()) {
  std::string value = map[key];
  ...
}
```

上述代码先用 `find` 查找 `key`，然后再通过 `operator[]` 再找了一次 `key`，是不高效的写法。

修正：

```c++
auto it = map.find(key);
if (it != map.end()) {
  std::string value = it->second;
  ...
}
```

通常我们都会有意识的避免调用两次 `find` 的重复查找，但像上述两类场景，`find` 隐藏在 `emplace` 和 `operator[]` 背后，有一定的隐蔽性。在某些场景下，这会带来较大的性能损失，譬如：使用 `rapidjson` 库时，如果没有开启使用 `map` 的宏，那么 `FindMember` 函数是通过遍历数组实现的，此时重复查找会带来很大开销。

## 22. 延迟计算

在有分支判断的代码流程中，有部分分支不会执行到，因此部分计算可以延迟到必要的时候才执行，减少无意义的计算。

反例：

```c++
void Run() {
  auto task = std::make_shared<Task>();
  task->SetName(process_name);
  if (!task_flow->Exists(process_name)) {
    return;
  }
  // do something with task
  ......
}
```

上述例子中 `task` 对象的构造和设置可以延迟到判断语句之后。

修正：

```c++
void Run() {
  if (!task_flow->Exists(process_name)) {
    return;
  }

  auto task = std::make_shared<Task>();
  task->SetName(process_name);
  // do something with task
  ......
}
```

## 23. 提早计算

有延迟计算，相应也有提早计算。在一个需要反复执行的函数中，有部分计算逻辑用于产出多次执行都不会有变化的信息，则这些信息可以提早计算，减少反复执行时的重复运算。

反例：

```c++
void Worker::RequestHandle(const Task& task) {
  auto graph = BuildExecuteGraph(process_config);  // 使用进程级配置构造任务执行流程图（DAG）
  ExecuteGraph(graph, task);  // 执行流程图
  ......
}
```

上述例子中，`RequestHandle` 是后台服务请求接口的响应函数，每一个请求都会触发一次 `RequestHandle` 函数调用。`BuildExecuteGraph` 函数是基于进程级配置构造执行流程图，只要配置相同，多次调用 `BuildExecuteGraph` 产出的 `graph` 对象都是一样的，因此没有必要每一个请求都去构造流程图，再考虑到 `BuildExecuteGraph` 可能有高耗时计算，因此这个函数适合放在 `Worker` 对象构造函数中执行。

修正：

```c++
Worker::worker() {
  graph_ = BuildExecuteGraph(process_config);  // 使用进程级配置构造任务执行流程图（DAG）
}

void Worker::RequestHandle(const Task& task) {
  ExecuteGraph(graph_, task);  // 执行流程图
  ......
}
```

## 24. 减少对象的隐藏拷贝

非必要的对象拷贝是很常见的性能浪费，并且有些时候拷贝是隐藏在背后发生的，不容易发现。比较常见的是函数参数类型定义不合理，引发对象拷贝。

反例：

```c++
void DoSomething(std::string info) {
  // do something with info string
}
```

上述例子中，很明显可以看到 `info` 参数在传参时会触发拷贝，可以修改为 `const&`。有些拷贝会很隐晦，譬如下面不合理使用 `std::vector` 带来隐藏的对象拷贝。

反例：

```c++
int main() {
  std::vector<Demo> demos;
  demos.emplace_back("a");
  demos.emplace_back("b");
  demos.emplace_back("c");
  demos.emplace_back("d");
  ......
  std::stable_sort(demos.begin(), demos.end(), [](const Demo& a, const Demo& b) -> bool { return a.info_ < b.info_; });
}
```

上述例子中，有两处地方会触发对象拷贝，第一处是 `std::vector<Demo>` 容器扩容时，第二处是 `std::stable_sort` 时：

- 使用 `vector` 时，如果可以预先知道容器元素个数，应该先用预留空间，然后再插入元素，消除容器扩容。
- 在对 `vector` 做排序时，考虑到数组排序会引发大量的元素移动，应该想办法避免，譬如考虑换成使用 `map`。

修正如下：

```c++
int main() {
  std::map<std::string, Demo> demos;
  demos.emplace("a", demo_a);
  demos.emplace("b", demo_b);
  demos.emplace("c", demo_c);
  demos.emplace("d", demo_d);
  ...
}
```

修正代码使用 `map` 替换 `vector`，元素在插入时保持有序，不需要再执行排序环节，也就消除了排序带来的隐藏拷贝。隐藏拷贝有时候也会在多个函数的协作场景下发生。

反例：

```c++
// Factory class
std::string Factory::GetTypeName() {
  return type_name_;  // type_name_ 是成员变量
}

// User class
void User::DoSomething() {
  Factory factory;
  std::string type_name = factory.GetTypeName();
  // type_name 后续只有只读应用
  ...
}
```

上述例子的 `DoSomething` 函数中，`factory` 变量的生命周期不短于使用者函数，因此 `GetTypeName()` 函数可以设计为返回 `const&`，使得函数调用者的 `type_name` 变量也可以定义为 `const&`，进而消除掉字符串拷贝。

减少对象的隐藏拷贝是知识点很广的话题，除了上述的三类例子，前面提到的 C++ `emplace` 系列语法也是为了消除隐藏的对象拷贝。

## 25. 非必要的防御

通常我们写代码会很小心，甚至有时候会小心过头，譬如没有从全局考虑，在一系列函数的执行流程中，每一个函数内部都加上防御判断，显得繁琐又低效。通常有一个原则：只判断一次。譬如：如果一个成员变量是类的关键成员变量，那么其有效性应该在对象构造或者其他类似时机做判断，不应该在后续多个函数的多次执行中做判断。

反例：

```c++
using ConfigPtr = std::shared_ptr<Config>;

void Handle(const Context& ctx) {
  ConfigPtr config = GetConfig();
  if (config == nullptr) {
    return;
  }
  CreateTask(ctx, config);
}

void CreateTask(const Context& ctx, const ConfigPtr& config) {
  if (config == nullptr) {
    ...
  }
  ...
}
```

上述例子中，对 `config` 做了两次判空，是有冗余的，应该在获取到 `config` 的地方做一次判断即可。

## 26. 重复的文档

文档重复会导致后续的修改工作量加大，并且很可能遗漏修改，违背 `ETC(easy to change) 原则`。常见的重复案例：

- 入门指引重复，在团队有新人入门手册（一般是 iwiki 文档）的情况下，项目 README 中也对这部分新人入门内容做了详细介绍，这会导致后续更新时需要两处都做更新，建议 `README` 可以引用 `iwiki` 文档；
- 代码注释重复，譬如：相同注释同时出现在 `h` 文件和 `cpp` 文件、基类和派生类都给重载的接口函数写了注释， 多个地方对同一个功能做注释说明，容易导致修改遗漏，进而产生过期注释，因此建议注释也确保不重复。

## 27. 重复的代码

同一段逻辑在项目中多次出现，一方面是代码显得冗长，一方面是给修改带来工作量，因此尽量不要出现重复代码，重复的逻辑应该抽取为公共函数。

## 28. 避免暴露内部细节

在设计一个类以完成特定功能时，建议提供最小限度的接口，并避免将类的内部信息暴露给使用者。使用者只需看到类提供的功能，而无需了解其内部实现。这有两个原因：

- 减轻使用者的负担：如果使用者需要关注功能的内部实现细节，将增加他们的负担，这不是一个易于使用的设计。
- 实现细节易变：如果使用者知晓这些细节，就可能依赖它们。后续的实现变更将需要与使用者一同修改，增加了改动的成本，这不是一个易于修改的设计。

反例：

```c++
// 银行账号
class BankAccount {
 public:
  std::string account_number;
  std::string account_name;
  double balance;

  void Deposit(double amount) {
      balance += amount;
  }

  void Withdraw(double amount) {
      balance -= amount;
  }
};
```

上述例子中，`BankAccount` 类暴露了其内部细节，包括`账户号码（account_number）`、`账户姓名（accout_name）`和`余额（balance）`。使用者可以直接访问和修改这些成员变量，而无需通过类提供的方法进行操作。

## 29. 过度的封装

有些一两行代码完成的功能，并且未来不会有新的扩展，就没必要做封装。

反例：

```c++
double ComputeCosine(const std::vector<float>& v1, const std::vector<float>& v2) {
  double v1_norm = ComputeNorm(v1);
  double v2_norm = ComputeNorm(v2);
  if (fabs(v1_norm) < 1e-6 || fabs(v2_norm) < 1e-6) {
    return 0.0;
  }
  return ComputeDotProduct(v1, v2) / (v1_norm * v2_norm);
}

double ComputeNorm(const std::vector<float>& v) {
  return hnswlib::SpaceNorm::GetInstance()->ComputeNorm(v.data(), v.size());
}
```

上述例子中，`ComputeNorm` 函数内只调用了 `hnsw` 的 `ComputeNorm` 函数，逻辑简单且未来不会扩展，因此这里没有必要封装为函数，直接在 `ComputeCosine` 函数中调用 `hnsw` 的 `ComputeNorm` 即可。

## 30. 类的职责需要清晰

一个类应该只有一个用途，其职责是唯一且清晰的，否则会带来两方面的问题：

- 如果一个类在程序中承担多种功能，那么经过一段时间之后，这个类可能会变得特别巨大，进而影响代码阅读效率和需求迭代速度。
- 如果一个类的职责未有明确的约束，那么在新加代码时便容易陷入纠结：这个代码放在哪里更合适？ 这是可以避免的内耗。

反例：

```c++
 // 请求上下文管理
 struct SessionContext {
  // 上报请求 trace 日志
  void ReportRequestTrace() {
    std::string report_log = GenerateNoticeInfo();
    WriteLocalLog(report_log);
    GAttaReporter->TraceReport(search_req_->header().request_id(), report_log);
  }


  SearchRequestPtr search_req_;  ///< 请求
  DebugMgr debug_mgr_;  ///< debug 管理
  SliderTimePtr slide_time_;  ///< 耗时滑动窗口
  ...
 };
```

上述例子中，`SessionContext` 的职责不清晰，既作为纯数据类，又带有功能函数，应该将功能函数移除，只用作数据承载。

## 31. 避免潜规则

代码中的潜规则，会影响阅读效率，会给后续代码修改挖坑，面对潜规则，第一选择是消除潜规则，第二选择是添加注释。

反例1：

```c++
void Worker::Init() {
  query_context_->SetInterfaceName();
  query_context_->Init();
  ...
}

void QueryContext::Init() {
  // 使用 interface_name_ 做一些事情
}
```

上述例子中的 `QueryContext::Init()` 函数依赖 `SetInterfaceName()` 先执行，但从 `Init` 函数命名上看不出来有这层依赖，并且命名为 `Init` 的函数是为对象做初始化，应该是对象构造完成后第一个调用的函数。上述的代码将依赖关系隐藏起来，并且其 `Init` 函数和惯用法不符，在代码的可读性、可维护性上较差。

反例2：

```c++
// 获取 AB 实验命中的实验信息
AbtestDetail GetAbtestPolicy(const std::map<std::string, AbtestDetail>& abtest_instances, const std::set<std::string>& req_bucket_ids) {
  for (const auto& [id, detail]: abtest_instances) {
    if (req_bucket_ids.find(id) != bucket_sids.end()) {
      return detail;
    }
  }
}
```

上述例子在判断命中哪个实验时，隐藏着一个判断规则：实验 `ID` 字母序排前面的实验优先判断命中。这个策略如果是合理的，应该增加注释说明。

## 32. 直接的表达

茴字有 N 种写法，实现某个功能的代码也一样，我们建议选择不拐弯抹角，更直接的表达。

反例：

```c++
if (map.count(key) == 0) {
  // not find
}
```

上述例子用 `count` 来实现元素查找，功能上可行，但理解起来会有多层转换，建议不要这么写，应该更直接的表达，用 `find` 来实现元素查找。

反例：

```c++
if (!plugin) {
  // plugin is nullptr
}
```

上述例子用 `!` 运算符做非空判断，不如用 `if (plugin == nullptr)` 表达直接。

在混合使用 C 语言和 C++ 语言 API 的代码中，使用 `!` 运算符也容易写出错误代码，譬如：

反例3：

```c++
int ret_c = CallCApiReturnZeroMeanSuc();
if (!ret_c) {  // 注：错误写法，且容易让读者误以为是判断失败的分支
  // suc
}

bool ret_cpp = CallCppApiReturnTrueMeanSuc();
if (ret_cpp) {  // 注：正确写法
  // suc
}
```

上述例子对 `ret_c` 的判断写法不合理，应该用 `if (ret_c == 0)` 表达更直接，特别是在 C、C++ 风格 API 混用的场合下，用直接表达的写法，让代码更不易出错。

我们提倡更直接的表达，上述的两个例子都是 if 条件里加了 `== x`，但有些场景也需要避免画蛇添足，譬如：`if (ret_cpp == true)` 这种写法就是不合理的，因为 if 原本的语义就是用来判断 `bool` 变量的，无需再添加 `== true/false`。

## 33. 更少的代码

更少的代码，带来更少的 bug 和更快的阅读效率。在写代码过程中，我们应该遵循一个原则：“非必要不保留”，能去掉的尽量都去掉，直到不能再精简为止。

反例：

```c++
class Demo {
 private:
  void DoA();
 private:
  void DoB();
 private:
  void DoC();
  ...
}
```

上述例子中，非必要的写了多个 `private:`，应该去掉。

反例：

```yaml
# yaml 配置文件
prompt_service:
  Prompt_service_http:
    prompt_service_http_url: http:xxx
    prompt_service_http_token: xxxx
    ...
```

上述例子配置文件中，下层级 `key` 命名都带着上层级 `key` 作为前缀，去掉前缀 `key` 不会影响功能，但可以提高阅读效率，应该精简掉前缀 `key`。

反例：

```c++
class KeyValueWrapper {
 public:
  KeyValueWrapper () = default;

  void SetValue(...);
  std::string GetValue(...)
  ....
}
```

上述例子中的默认构造函数可以去掉，不需要显式的写出来。

反例：

```c++
std::string empty_string = "";
```

上述例子中 `std::string` 的默认构造函数会将字符串置为空字符串，不需要显式的赋值。  
反例：

```c++
std::string ReadTotalFile() {
  std::ifstream in(file_path.c_str());  // 注：错误
  in.seekg(0, in.end);
  std::string content;
  content.resize(in.tellg());
  in.seekg(0, in.beg);
  in.read(content.data(), content.size());
  in.close();  // 注：错误
  return content;
}
```

上述例子中，有两处错误，首先是构造 `std::ifstream` 对象时，非必要的将 `string` 参数转为 C 格式字符串，然后是 `ifstream` 对象非必要的调用了 `close()` 接口。这里 `std::ifstream` 支持 `std::string` 参数，且其析构函数也会执行 `close()`。
反例：

```c++
class Demo {
 private:
  void DoA();
  // void DoB();
  // void DoC();
  // void DoD();
  // void DoE();
  // void DoF();
  ...
}
```

上述例子中，废弃代码直接删除即可，后续如果需要恢复代码可以通过 git 查看历史版本恢复。

## 34. 避免虚假的单测

单元测试是为了发现问题，不是为了跑覆盖率。被测函数的核心输出应被检查到，否则就是虚假单测。

反例：

```c++
bool GetValue(const std::string& key, std::string& value) {
  value = ...;
  return true;
}

TEST_F(KvTest, GetValue) {
  ......
  ASSERT_TRUE(GetValue(key));
}
```

上述例子中，`GetValue` 的单测函数只检查其 `bool` 返回值，没有判断获取的 `value` 值是否符合预期，因此这个单测是不完整的，虽然单测覆盖率达到 100%，但没有检查核心功能的执行结果，无法为迭代开发提供保护，是一个虚假单测。

## 34. 避免不原子的单测

单测是最底层函数的测试，一个单测函数应该只对应一个功能函数，如果一个单测函数测试了多个功能，会导致后续单测的维护非常困难。

反例：

```c++
TEST_F(DatabaseTest， InitReader) {
  skit::DatabaseImpl database;
  EXPECT_FALSE(database.Init(nullptr, false));
  auto option = GetDatabaseReadOption();
  EXPECT_TRUE(database.Init(option, true));
  EXPECT_TRUE(database.Commit());
  EXPECT_EQ(database.GetDocCount(), 1000);
  EXPECT_EQ(database.GetDBPath, "xxx");
  ...  // 还有几十行对 database 接口的测试
}
```

上述例子的 `InitReader` 单测函数，测试了大量的 `database` 接口，这不是原子的单测，多个 `database` 接口的修改都会对该单测函数造成影响，可读性和可维护性都很差，应该将该大单测函数拆为多个小单测函数。

## 35. 避免单测统计不全

当我们使用 `gcc` 的编译优化时，可能会导致部分函数被内联，进而导致单测覆盖统计不完整。有两种修改方式：

- 将单测的构建修改为：O0，不做编译优化，默认不内联
- 指定编译选项为 `-fno-inline`，取消内联

注：编译选项 `-fno-inline-functions` 只能禁止编译器自动内联。

## 36. 一致性

相似的逻辑采用一致的实现，有利于提升阅读效率，也可以避免困惑。

反例：

```c++
// 系统开关配置
std::string system_close_cache;
trpc::TrpcConf::LoadSingleKvConfig("rainbow", "core.conf", "close_cache", system_close_cache);
...
// 资源开关配置
std::string res_open_cache;
trpc::TrpcConf::LoadSingleKvConfig("rainbow", "res.conf", "open_cache", res_open_cache);
...
```

上述例子中对系统和资源粒度的 `cache` 控制开关，采用了不同的配置设计，系统开关配置的是“关闭cache”为 `true` 或者 `false`，资源开配置的是“打开cache”为 `true` 或者 `false`。作为相似的开关配置，这里应该采用一致的设计，统一为“open_cache”，否则会带来多余的理解负担。

反例：

```c++
struct Config {
  ExpireConfig expire_config;  // 过期配置
  extra_field; // 提取字段
  extra_schema;  // 提取schema
  extra_... // 更多和提取相关的配置信息
  ...
};

struct ExpireConfig {
  // 过期相关的配置
};
```

上述例子中对 `Config` 类的设计没有遵循一致性原则，过期相关的配置抽取到了独立的类中，提取相关的配置也应该同样抽取出来。

## 37. 进程退出时应主动停止多线程

我们经常会使用多线程来干一些异步的计算任务、IO 任务，多线程通常封装在类中，并使用 `RAII` 的思想来实现线程关闭和资源释放。这些类应该提供一个 Stop 函数，用于进程退出时被调用，而不要依赖单实例对象的析构来退出工作线程，因为这会导致多个工作线程串行退出，进而拖慢进程整体退出速度。

例子：

```c++
class WorkerWrapper {
 public:
  WorkerWrapper() : thread_([this] { Work(); }) {}
  ~WorkerWrapper() {
    stop_ = true;
    thread_.join();
  }

  void Stop() { stop_ = true; }

  void Work() {
    while (!stop_) {
      // 工作线程做一些循环执行的工作
      ......
    }
  }

 private:
  bool stop_ = false;
  std::thread thread_;
};

int main() {
  std::vector<WorkerWrapper> workers(10);  // 模拟 10 个工作线程

  // 模拟主线程做一些其他事情
  std::this_thread::sleep_for(std::chrono::seconds(3));

  // 注意：主动通知停止
  for (auto& worker : workers) {
    worker.Stop();
  }
}
```

上述例子模拟多线程退出场景，在进程退出时如果没有主动通知多线程退出，则 10 个工作线程会在 `workers` 对象析构时逐个元素析构触发串行退出，会较长时间的阻塞进程退出。另外，在部分场景下，可以考虑使用 `trpc` 的定时任务功能：`SubmitPeriodicalTask` 代替工作线程。

## 38. 多线程场景下变量的生命周期

当我们写简单的串行代码时，通常会注意到变量的生命周期，并避免犯错，譬如：不返回局部变量的地址。但当我们在写多线程程序，并叠加上 `lambda` 语法时，则很容易忽略变量的生命周期，而出现野指针访问。

反例：

```c++
void DoSomethingAsync() {
  std::string info = "some information";
  std::thread worker([&info] {
    std::this_thread::sleep_for(std::chrono::seconds(1));
    std::cout << info << std::endl;
  });
}
```

上述例子会出 `coredump`，因为 `info` 是 `lambda` 引用捕获，引用本质上是地址，当 `DoSomethingAsync` 函数执行完时，`info` 对象被析构，而地址还被工作线程拿着并访问。这个例子较容易看出来问题，如果把这个例子的工作线程修改为 `RPC` 调用的异步回包响应，则会更具隐蔽性。

反例：

```c++
std::string running_info = ...;
...
task_processer->Process(ctx).Then([this, &running_info, &ctx](trpc::Future<>&& fu){...});
```

上述例子和 RPC 的回调交织在一起，野指针问题具有隐蔽性。
多线程下访问有生命周期安全风险的变量，通常有几种解法：

 - 将需要跨线程访问的变量定义为长生命周期变量，譬如：全局变量、某个长生命周期对象的成员变量
 - 拷贝需要跨线程访问的变量，为每一个跨线程访问者都拷贝一份该变量的副本
 - 将需要跨线程访问的变量定义为智能指针，并为每一个跨线程访问者拷贝一份智能指针对象的副本

这几种方式各有优缺点，长生命周期变量需要做好设计；全局变量有可读性减分和析构顺序不可控的隐患；拷贝变量需要付出性能成本；智能指针会有析构时机不可控的代价，总之，没有免费的午餐，在实际应用中，应选择业务代价最小的方案。

## 39. 最少知识原则

让一个函数的参数类型尽可能的“小”，使得函数里的代码没有机会越界，是内聚设计的一种体现，也让读者阅读代码时，减少知识负担，获得更多的确定性。

反例：

```c++
// 添加调试信息
void AddDebugInfo(const Context& ctx, const std::string& info) {
  ctx->debug_mgr->Add(info);
}
```

上述例子中，`AddDebugInfo` 函数只使用到 `ctx` 的 `debug_mgr` 成员，函数的参数也应该只传递 `debug_mgr` 对象，不需要传递 `ctx` 对象。

## 40. 更多的确定性

除了最少知识原则可以让读者有更多的确定性，在函数定义、类型定义时，也有一些“给读者更多确定性”的注意点。

反例：

```c++
class BaseWorker {
 public:
  virtual void DoHandle() = 0;
};

class SkitWorker : public BaseWorker {
 public:
  // 缺少 override 关键字，读者无法快速确定这是派生类重写的函数
  void DoHandle() {
    ......
  }
};
```

上述例子中，对于派生类重写的函数，应该加上 `override`。

反例：

```c++
for (auto& item : values) {
  // 以只读的方式使用 item
}
```

上述例子中，`item` 定义为引用，意味着后续的使用可以是只读，也可以是修改，这有不确定性，在实践中，我们通常这样子约束：

- 如果是只读，则定义为 `const auto&`
- 如果要修改，则定义为 `auto&`
- 如果要转移所有权，则定义为 `auto&&`

## 41. 内聚的插件设计

两个会一起变动的东西，应该放到一起，这是内聚；而两个关系不紧密的东西放到一起，则是耦合。内聚的设计，提升代码的可读性，也使得修改局部化，编译也更快。业务的发展很难预判，因此我们在业务发展初期，通常会将系统框架设计为“插件系统”，意思是当有新功能开发时，可以可插拔的加入和删除。我们写的插件系统足够內聚吗？

反例：

```c++
// plugin_factory.h
// 插件工厂
class PluginFactory {
 public:
  PluginFactory() {
    Register("plugin_a", PluginA);
    Register("plugin_b", PluginB);
    ......
  }
};

// plugin_a.h
// 插件A
class PluginA : public PluginBase {...};

// plugin_b.h
// 插件B
class PluginB : public PluginBase {...};
```

上述例子中，当新增一个插件时，不止要写插件代码，还需要修改插件工厂，不够內聚，更好的实现可以做到：当源码加入编译时，插件存在，当源码删除时，插件消失。

修正：

```c++
// plugin_factory.h
// 插件工厂
class PluginFactory {
 public:
  PluginFactory() {}
};

// 自动注册类，构造函数执行注册
class AutoRegister {
 public:
  AutoRegister(name, builder) {
    PluginFactory->RegisterPlugin(name, builder);
  }
}

// plugin_a.h
// 插件A
class PluginA : public PluginBase {...};

// plugin_a.cc
// 全局变量，构造函数执行注册
AutoRegister register("plugin_a", PluginA);

// plugin_b.h
// 插件B
class PluginB : public PluginBase {...};

// plugin_b.cc
// 全局变量，构造函数执行注册
AutoRegister register("plugin_b", PluginB);
```

注：插件A和B的编译需要加上 `alwayslink = True`

上述修正后的代码，通过全局变量的构造函数，实现插件自注册，也就实现了源码级的插件可插拔。

## 42. 项目依赖注意事项

依赖的模块应避免出现不受本项目开发者控制的变更。一方面是更安全，避免受依赖库的不兼容升级影响；另一方面是开发过程中的增量编译更快，不会因依赖仓库升级而导致编译缓存失效。实际操作建议：
- 使用 bazel 和 tag。本项目使用 bazel 编译，依赖模块通过 tag 引入。
- 使用 git 子模块和 commit id。如果无法使用 bazel+tag 模式，也可以采用 git 子模块和 commit id 来引入依赖。
